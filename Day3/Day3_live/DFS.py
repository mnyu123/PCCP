# ------------------------------------------------------------------
# 깊이 우선 탐색(DFS)
# 스택으로 구현한다면
# 1. 시작점을 stack에 추가함
# 2. 스택의 가장 끝에 저장된 점을 바라?본다?
# 3-1. 그 점에서 갈 수 있는 곳을 지정해서 stack에
# append(추가란 말임) & 방문했다고 처리함
# 3-2. 갈 수 있는 곳이 없으면 stack에서 pop
# 4-1. 2~3번 반복
# 4-2. 언제가지? 스택이 전부 비어있을 때까지
# ------------------------------------------------------------------

from collections import deque

n, m = 4, 6

mat = [[1, 0, 1, 1, 1, 1],
       [1, 1, 1, 0, 1, 0],
       [1, 0, 1, 0, 1, 1],
       [1, 1, 1, 0, 1, 1]]

# 예전에 쓰던 4방향 보는거 쓸려고 가져옴
fromx = [0, 0, 1, -1]
fromy = [1, -1, 0, 0]

# 시작점
# 1. 시작점을 큐에 추가
start_x, start_y = 0, 0  # <- 0,0이 시작점임
end_x, end_y = n-1, m-1  # <- 얘는 마지막 지점임
# (왜 -1이냐면 0,1,2,3 이렇게 가서 하나씩 모자라잖아)

stack = deque()  # DFS 깊이 우선탐색은 스택을 씀
stack.append((start_x, start_y))  # 스택에 시작점 추가

# 길을 벽으로 만드는 방식으로 방문처리(0으로 만들면 못간다고 판단하잖아)
mat[start_x][start_y] = 0

success = False

# 2. 스택의 가장 끝에 저장된 점을 바라?본다?
# 3-1. 그 점에서 갈 수 있는 곳을 지정해서 stack에
# append(추가란 말임) & 방문했다고 처리함
# 3-2. 갈 수 있는 곳이 없으면 stack에서 pop
# 4-1. 2~3번 반복
# 4-2. 언제가지? 스택이 전부 비어있을 때까지

while stack:
    # x,y = stack.pop() # pop을 하면 깊이 우선탐색이 아님
    # 그래서
    x, y = stack[-1]  # 그냥 -1해서 스택 가장끝에 저장된 점을 봄
    # 처음 시작점 바라봄
    # 다음 반복때는 갈 수있는 그 다음지점이 '기준' 이 되서
    # 그게 스택에 제일 위니까 제일 위에있는 좌표기준으로 또 갈데를 찾음
    # 근데 없어서 else 조건 터지면
    # 스택에서 한단계씩 날아가면서 돌아감

    # 마지막점에 온거면
    if (x, y) == (end_x, end_y):
        success = True  # 성공임

    # x , y가 갈만한 모든 상하좌우 길 체크함
    for d in range(4):
        nx = x + fromx[d]
        ny = y + fromy[d]

        if (0 <= nx) and (nx < n) and (0 <= ny) and (ny < m) and (mat[nx][ny] == 1):
            # 제한 내용
            # 1. 길 이여야함(1이여야 한다고) # mat[nx][ny] == 1
            # 2. 방문 안했어야함 근데 여기는 이미 0으로(벽)으로 만들어 둬서
            # 방문한거 따로 체크는 안해도 됨.
            stack.append((nx, ny))

            # 방문 했으면? 또 벽으로 바꿔야제
            mat[nx][ny] = 0  # 벽 생성

            break  # 왜 break?
            # 다른 지점을 방문 안하고 직진할거라서
            # 다음 반복때는 nx,ny 이 자식이 다음번의 x,y로 사용되야해서

    # 파이썬-문법 -> "for-else" 반복이 break를 만나지 않고
    # 무사히 반복이 끝난 경우에 실행되는거임
    # 스택에 추가(append)가 안된 경우에는 break도 실행이 안되었고 ,
    # 반복은 무사히 끝난 상태 : 스택에서 pop(날린다)

    #  3-2. 갈 수 있는 곳이 없으면 stack에서 pop <- 여긴 이 상황임

    else:
        stack.pop()

print(success)